
#include <iostream>
void desc1()
{
    int x = 1;
    //error
    //后置的++操作在编译器中首先会生成一份x值的临时拷贝，然后才对x进行递增，最后返回的是临时拷贝的内容
    //前置的++操作会将x自增之后直接返回自身
    //所以后置++返回的是一个临时拷贝，是一个右值，而前置++返回的是一个变量，为左值
    // int* p1 = &x++;
    int* p2 = &++x;
}

int value1 = 1;
int get_val()
{
    return value1;
}

void desc2()
{
    int y = get_val();
    //error 上述报错同理，返回的是一个右值，value1的临时拷贝
    // int*p = &get_val();
}

void desc3()
{
    int a = 10;               
    int &x1 = a;           // 编译成功，左值引用指向左值
    // int &x2 = 10;          // 编译失败，左值引用指向右值
    const int &x3 = 10;    // 编译成功，常量左值引用可以指向右值
}

// 然常量左值引用可以引用右值的这个特性在赋值表达式中看不出什么实用价值，但是在函数形参列表中却有着巨大的作用
// 一个典型的例子就是复制构造函数和复制赋值运算符函数，通常情况下我们实现的这两个函数的形参都是一个常量左值引用
class X
{
public:
    X();
    X(const X&);
    X& operator=(const X&) {return *this;}
};

X make_x()
{
    return X();
}

/**
 * 如果我们去掉拷贝构造函数中的 const，那么 X x3(make_x()); 将报错，因为 make_x() 函数返回的是右值，
 * 而非常量左值引用无法绑定到make_x()产生的右值上，导致传参失败。
 * 
 * 为什么非常量左值引用无法绑定到右值上：右值通常是临时的，可能会在语句结束后被销毁，而引用则可能会在稍后的代码中被使用。
 * 如果允许非常量左值引用绑定到右值上，那么在引用被使用时，可能会访问已经被销毁的对象，导致未定义行为。
 * 
 * 那为什么常量左值引用可以绑定右值
 * 从语义上讲，右值是一个临时变量，不应该被修改，而常量左值引用则保证了不会去修改右值
 * 
 * 常量左值引用可以绑定右值是一条非常棒的特性，但是他有很大的限制，他是常量
 * ，传入后我们无法修改该对象的内容。为此需要另一个特性，右值引用。
*/

int main()
{
    X x1;
    X x2(x1);
    X x3(make_x());
    x3 = make_x();


    return 0;
}