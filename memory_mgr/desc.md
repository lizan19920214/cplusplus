一、内存分配方式
内存分配方式有三种：

（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。


二、常见的内存错误及其对策
发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。


常见的内存错误及其对策如下：

（1）内存分配未成功，却使用了它。

编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 assert(p!=NULL) 进行检查。如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL) 进行防错处理。


（2）内存分配虽然成功，但是尚未初始化就引用它。

犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。

内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。


（3）内存分配成功并且已经初始化，但操作越过了内存的边界。

例如在使用数组时经常发生下标 “多 1” 或者 “少 1” 的操作。特别是在 for 循环语句中，循环次数很容易搞错，导致数组操作越界。所以要避免数组或指针的下标越界，特别要当心发生 “多 1” 或者 “少 1” 操作。


（4）忘记了释放内存，造成内存泄露。

含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。

动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定有错误（new/delete 同理）。


（5）释放了内存却继续使用它。

有三种情况：

（1）函数的 return 语句写错了，注意不要返回指向 “栈内存” 的 “指针” 或者 “引用”，因为该内存在函数体结束时被自动销毁。

（2）使用 free 或 delete 释放了内存后，没有将指针设置为 NULL。导致产生 “野指针”。

（3）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。


三、free 和 delete 把指针怎么啦？
别看 free 和 delete 的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。

用调试器跟踪下例，发现指针 p 被 free 以后其地址仍然不变（非 NULL），只是该地址对应的内存是垃圾，p 成了“野指针”。如果此时不把 p 设置为 NULL，会让人误以为 p 是个合法的指针。

如果程序比较长，我们有时记不住 p 所指的内存是否已经被释放，在继续使用 p 之前，通常会用语句 if (p != NULL)进行防错处理。很遗憾，此时 if 语句起不到防错作用，因为即便 p 不是 NULL 指针，它也不指向合法的内存块。

char *p = (char *) malloc(100);
strcpy(p, “hello”);
free(p); // p 所指的内存被释放，但是 p 所指的地址仍然不变
…
if(p != NULL) // 没有起到防错作用
{
	strcpy(p, “world”); // 出错，p 成为野指针
}

四、动态内存会被自动释放吗？
函数体内的局部变量在函数结束时自动消亡。很多人误以为下例是正确的。理由是 p 是局部的指针变量，它消亡的时候会让它所指的动态内存一起完蛋。这是错觉！

void Func(void)
{
	char *p = (char *) malloc(100); // 动态内存会自动释放吗？
}
我们发现指针有一些“似是而非”的特征：

（1）指针消亡了，并不表示它所指的内存会被自动释放。

（2）内存被释放了，并不表示指针会消亡或者成了 NULL 指针。

这表明释放内存并不是一件可以草率对待的事。也许有人不服气，一定要找出可以草率行事的理由：

如果程序终止了运行，一切指针都会消亡，动态内存会被操作系统回收。既然如此，在程序临终前，就可以不必释放内存、不必将指针设置为 NULL 了。终于可以偷懒而不会发生错误了吧？

想得美。如果别人把那段程序取出来用到其它地方怎么办？


五、有了 malloc/free 为什么还要 new/delete ？
malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。

对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。

因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete不是库函数。


我们先看一看 malloc/free 和 new/delete 如何实现对象的动态内存管理。示例如下：

class Obj
{
public :
	Obj(void){ cout << “initialization” << endl; }
	~Obj(void){ cout << “destroy” << endl; }
	void initialize(void){ cout << “initialization” << endl; }
	void destroy(void){ cout << “destroy” << endl; }
};

void useMallocFree(void)
{
	Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存
	a->initialize(); // 初始化
	//…
	a->destroy(); // 清除工作
	free(a); // 释放内存
}

void useNewDelete(void)
{
	Obj *a = new Obj; // 申请动态内存并且初始化
	//…
	delete a; // 清除并且释放内存
}
Obj 类的 initialize 函数模拟了构造函数的功能，destroy 函数模拟了析构函数的功能。useMallocFree 函数中，由于 malloc/free 不能执行构造函数与析构函数，必须调用 initialize 和 destroy 成员函数来完成初始化与清除工作。

useNewDelete 函数则简单得多。所以我们不要企图用 malloc/free 来完成动态对象的内存管理，应该用 new/delete。由于内部数据类型的 “对象” 没有构造与析构的过程，对它们而言 malloc/free 和 new/delete 是等价的。


既然 new/delete 的功能完全覆盖了 malloc/free，为什么 C++不把 malloc/free 淘汰出局呢？

这是因为 C++程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存。如果用 free 释放 “new 创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用 delete 释放 “malloc 申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以 new/delete 必须配对使用，malloc/free 也一样。


六、内存耗尽怎么办？
如果在申请动态内存时找不到足够大的内存块，malloc 和 new 将返回 NULL 指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。

（1）判断指针是否为 NULL，如果是则马上用 return 语句终止本函数。例如：

void Func(void)
{
	A *a = new A;
	if(a == NULL)
	{
		return;
	}
	…
}

（2）判断指针是否为 NULL，如果是则马上用 exit(1)终止整个程序的运行。 例如：

void Func(void)
{
	A *a = new A;
	if(a == NULL)
	{
		cout << “Memory Exhausted” << endl;
		exit(1);
	}
	…
}

（3） 为 new 和 malloc 设置异常处理函数。例如 Visual C++可以用 _set_new_hander 函数为 new 设置用户自己定义的异常处理函数，也可以让 malloc 享用与 new 相同的异常处理函数。详细内容请参考 C++使用手册。

上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。


有一个很重要的现象要告诉大家。对于 32 位以上的应用程序而言，无论怎样使用 malloc 与 new，几乎不可能导致“内存耗尽”。因为 32 和 64 位操作系统支持“虚存”，内存用完了，会自动用硬盘空间顶替。

可以得出这么一个结论：对于 32 位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把 Unix 和 Windows 程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。但是必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。

试图耗尽操作系统内存的示例程序如下：

void main(void)
{
	float *p = NULL;
	while(TRUE)
	{
		p = new float[1000000];
		cout << “eat memory” << endl;
		if(p==NULL)
			exit(1);
	}
}

七、malloc/free 的使用要点
函数 malloc 的原型如下：

void *malloc(size_t size);
用 malloc 申请一块长度为 length 的整数类型的内存，程序如下：

int *p = (int *) malloc(sizeof(int) * length);
我们应当把注意力集中在两个要素上：“类型转换” 和 “sizeof”。

malloc 返回值的类型是 void *，所以在调用 malloc 时要显式地进行类型转换，将 void * 转换成所需要的指针类型。
malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。所以在 malloc 的 “()” 中使用 sizeof 运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。

函数 free 的原型如下：

void free(void *memblock);
为什么 free 函数不象 malloc 函数那样复杂呢？这是因为指针 p 的类型以及它所指的内存的容量事先都是知道的，语句 free(p)能正确地释放内存。

如果 p 是 NULL 指针，那么 free 对 p 无论操作多少次都不会出问题。如果 p 不是 NULL 指针，那么 free 对 p 连续操作两次就会导致程序运行错误。


八、new/delete 的使用要点
运算符 new 使用起来要比函数 malloc 简单得多，例如：

int *p1 = (int *)malloc(sizeof(int) * length);
int *p2 = new int[length];
这是因为 new 内置了 sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new 在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么 new 的语句也可以有多种形式。例如：

class Obj
{
public :
	Obj(void); // 无参数的构造函数
	Obj(int x); // 带一个参数的构造函数
	… 
}

void Test(void)
{
	Obj *a = new Obj;
	Obj *b = new Obj(1); // 初值为 1
	… delete a;
	delete b;
}

如果用 new 创建对象数组，那么只能使用对象的无参数构造函数。例如：

Obj *objects = new Obj[100]; // 创建 100 个动态对象
不能写成：

Obj *objects = new Obj[100](1);// 创建 100 个动态对象的同时赋初值 1
在用 delete 释放对象数组时，留意不要丢了符号‘[]’。例如：

delete []objects; // 正确的用法
delete objects; // 错误的用法
后者相当于 delete objects[0]，漏掉了另外 99 个对象。

